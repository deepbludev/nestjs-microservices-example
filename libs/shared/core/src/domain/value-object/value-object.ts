import { DomainObject } from '../core/domain-object.abstract'
import {
  DomainObjects,
  DomainObjectType,
  IProps,
} from '../types/domain-object.types'

// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface IValueObjectProps extends IProps {}

/**
 * @class ValueObject
 * @classdesc Value Objects are immutable objects that do not contain any state
 * besides the generated by their props on instantiation.
 * They are only identified by their values, not by unique ids as entities do.
 * They are be immutable. Behaviors should not change the state of a value object,
 * but can rather create a new value object.
 * They have value semantics (equality defined by property values and class).
 * You can combine other value types that usually go together into a new value object type,
 * like address (city, street, country, postal code) or ...range, or ...type.
 * They can are used as entities props, encapsulating the validation logic.
 * The constructor should be private, and the static factory method that ensures
 * validity should be used instead.
 * @see https://martinfowler.com/bliki/EvansClassification.html
 * @see https://martinfowler.com/bliki/ValueObject.html
 */
export abstract class ValueObject<
  P extends IValueObjectProps
> extends DomainObject<P> {
  public override readonly domType: DomainObjectType =
    DomainObjects.VALUE_OBJECT

  protected constructor(public override readonly props: P) {
    super(props)
    this.props = Object.freeze(this.props)
  }

  /**
   * @description Value Objects are compared by their properties and class
   * @returns true if the value objects are equal in value.
   */
  equals<V extends ValueObject<P>>(vo: V): boolean {
    return this.isSameClass(vo) && this.hasEqualProps(vo)
  }

  /**
   * @description Get an instance copy.
   * @returns a copy of the value object.
   */
  clone<V extends ValueObject<P>>(): V {
    const constructor = Reflect.getPrototypeOf(this)?.constructor
    if (!constructor)
      throw new Error('Cannot clone Value Object: undefined constructor.')
    return Reflect.construct(constructor, [this.props])
  }
}
